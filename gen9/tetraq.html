<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>tetra q</title>
    <style display-source>
        [display-source] {
            display:     block;
            padding:     0 1em 2em;
            font-family: monospace;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
<script display-source>
    // ADFGHLMST
    // LH
    // XOQ - PUBEY
    // ecxydqpb
    const WorldShapeConfig = {
        field: [
            [0,0,0,0,0,0],
            [0,0,0,0,0,0],
            [0,0,0,0,0,0],
            [0,0,0,0,0,0],
            [0,0,0,0,0,0],
            [0,0,0,0,0,0],
            [0,0,0,0,0,0],
            [0,0,0,0,0,0],
            [0,0,0,0,0,0],
        ],
        shapes: {
              A:[
                [1,1],
                [1,1],
            ],D:[
                [1,1,1,1],
            ],F:[
                [1],
                [1],
                [1],
                [1],
            ],
            G:[
                [1,1,0],
                [0,1,1],
            ],
            H:[
                [1,0],
                [1,1],
                [0,1],
            ],
            S:[
                [1,1,1],
                [0,0,1],
            ],
            T:[
                [1,0,0],
                [1,1,1],
            ],
            M:[
                [1,1],
                [0,1],
                [0,1],
            ],
            L:[
                [1,0],
                [1,0],
                [1,1],
            ],
        },
        Qb: q=> q?1:0,
        Qx: d=> 1,
        Qo: d=> 0,
        Qw: q=> 1 <=q,
        Wq: q=> 1 * q,
        Qsex: (x,y)=> y||x,
    };
    const WorldShapeMaster = function () {
        const {field,shapes} = WorldShapeConfig;
        const { Qx, Qo, Qb } = WorldShapeConfig;
        const { Qsex,Wq,Qw } = WorldShapeConfig;
        const WSM = Object.assign(this);

        // ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ services

        const servicesOfShape = (({Qo,Qb,Qsex}) => ({
            pushMatter: shape => shape.map(Le=>[Qo(), ...Le]),
            antiMatter: shape => shape.map(Le=>[Le.toReversed()][0]),
            antiEnergy: shape => shape.map(Le=>Le).toReversed(),
            fromBinary: shape => shape.map(Le=>Le.map(q=>[Qb(q)][0])),
            makeBinary: shape => shape.map(Le=>Le.map(q=>[Qb(q)][0])),
            dataMirror: shape => shape.reduce(
                (ap,Le,e) => Le.map(
                    (q,c) => [...ap[c], q]
                ), [...shape[0].map(G=>[])]
                ),
            checkShape: shape => Array.isArray(shape) && shape.reduce(
                (check,layer) => Array.isArray(layer) && check
                ,shape),
            joinShapes: (shape, join, h = 0) => shape.reduce(
                (ap,Le,e) => [ ...ap,Le.map(
                    (x,c) => {
                        const U = true
                            && e >= h
                            && e <  h+ join.length
                            && c <  join[0].length
                            ;
                        const y = U && join[e-h][c] || Qo();
                        return Qsex(x,y);
                    })],
                    []),
        }))({Qo,Qb,Qsex});

        const servicesOfField ={



        };

        //~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ workers

        const sporadicShape = f => shapes[(
            K => K[Math.floor(Math.random()*K.length)]
            )( Object.keys(shapes) )];

        const targetedShape = target =>
            (Object.keys(shapes).includes(target) && shape[target])
            || (target==='field' && field)
            || false;

        const createdShape = shapeDNA => new WSM.Csp(shapeDNA);

        const checkedShape = shape => WSM.Fsp.checkShape(shape);

        const shapeEnergyWeight = (shape, positive = true) => {
            const Ds = WSM.Fsp.dataMirror(shape);
            const Em = C=> C.find(Qw) ? C.findLastIndex(Qw) +1:0;
            const En = C=> C.find(Qw) ? C.findIndex(Qw)       :0;
            const De = Ds.map(positive? Em:En );
            return De;
            };

        const mergeEnergyHeight = (field, shape) => {
            const Ef = shapeEnergyWeight(field);
            const Es = shapeEnergyWeight(shape);
            const Ep = shapeEnergyWeight(shape,false);
            const Hm = (h,a,c) =>(
                e => e>h ? e:h
            )(
                Es[c]?  1*Ef[c] -1*Ep[c] :0
            );
            const h = Ef.reduce(Hm,0);
            return h;
            };

        const mergeAllowed = (field, shape) => true;
        const mergeMake = (field, shape) => {
            const {joinShapes} = WSM.Fsp;
            const h = mergeEnergyHeight(field, shape);
            const merge = mergeAllowed(field, shape)
                ? joinShapes(field,shape,h)
                : field ;
            return merge;
        };

        WSM.shapeEnergyWeight = shapeEnergyWeight;
        WSM.mergeEnergyHeight = mergeEnergyHeight;

        // ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ shape

        const WorldShape = function WorldShape (DNA={}) {
            const ribosome = ({
                shape:S, form:F,
            }) => ({
                shape: checkedShape(S) || targetedShape(F) || sporadicShape(),
            });
            const transcription = {DNA, ...ribosome(DNA)};
            const RNA = Object.assign(this,transcription);

            //~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ shape api

            RNA.take = pill => {
                RNA.shape = mergeMake(RNA.shape, pill.shape);
                return RNA;
                };
            RNA.push = f => {
                RNA.shape = WSM.Fsp.pushMatter(RNA.shape);
                return RNA;
            };
            

        }; // WorldShape

        // ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ Master api

        WSM.Fsp = servicesOfShape;
        WSM.Fsf = servicesOfField;
        WSM.Csp = WorldShape;
        WSM.born = createdShape;
    };
    const WorldShape = function (DNA={}) {
        const {field, shape} = WorldShapeConfig;
        const { Qx, Qo, Qw } = WorldShapeConfig;

        const serviceForShape ={
            pushMatter: shape => shape.map(Le=>[Qo(), ...Le]),
            antiMatter: shape => shape.map(Le=>[Le.toReversed()][0]),
            antiEnergy: shape => shape.map(Le=>Le).toReversed(),
            fromBinary: shape => shape.map(Le=>Le.map(q=>[Qb(q)][0])),
            dataMirror: shape => shape.reduce(
                (ap,Le,e) => Le.map(
                    (q,c) => [...ap, q]
                ),  shape[0].map(G=>[])
                ),
            checkShape: shape => Array.isArray(shape) && shape.reduce(
                (check,layer) => Array.isArray(layer) && check
                ,true),
        };
        const services = {
            pushMatter: shape => shape.map(Le=>[Qo(), ...Le]),
            antiMatter: shape => shape.map(Le=>[Le.toReversed()][0]),
            antiEnergy: shape => shape.map(Le=>Le).toReversed(),
            fromBinary: shape => shape.map(Le=>Le.map(q=>[Qb(q)][0])),
            checkShape: shape => Array.isArray(shape) && shape.reduce(
                    (R,layer) => Array.isArray(layer) && R
                    ,true),
            dataMirror: shape => shape.reduce(
                (ap,Le,e) => Le.map(
                    (q,c) => [...ap, q]
                ),  shape[0].map(G=>[])
                ),
            joinShapes: (field, shape, h) => field.reduce(
                (ap,Le,e) => [ ...ap,Le.map(
                    (x,c) => {
                        const U = true
                            && e >= h
                            && e <  h+ shape.length
                            && c <  shape[0].length
                            ;
                        const y = U && shape[e-h][c] || Qo();
                        return y||x;
                    })],
                    []),
            chooseRandom: shapes => shapes[(
                K => K[Math.floor(Math.random()*K.length)]
                )( Object.keys(shapes) )],
        };// end of shapeService

        const ribosome = DNA => ({
            DNA,
            shape: (DNA => {
                const {checkShape, chooseRandom} = services;
                const {shapes, fields} = { shapes, fields:[field] };
                const uS = DNA.shape && checkShape(DNA.shape);
                const uN = Object.keys(shapes).includes(DNA.form);
                const uF = DNA.form === 'field';
                return (uS && DNA.shape)
                    || (uN && shapes[DNA.form])
                    || (uF && fields[0])
                    || chooseRandom(shapes);
                })(DNA),
        });
        const transcription = ribosome(DNA);
        const RNA = Object.assign(this,transcription);
    };
</script>

<script display-source>
    const field = [
        [0,0,0,0,0,0],
        [0,0,0,0,0,0],
        [0,0,0,0,0,0],
        [0,0,0,0,0,0],
        [0,0,0,0,0,0],
        [0,0,0,0,0,0],
        [0,0,0,0,0,0],
        [0,0,0,0,0,0],
        [0,0,0,0,0,0],
    ];
    const shape = {
          A:[
            [1,1],
            [1,1],
        ],D:[
            [1,1,1,1],
        ],F:[
            [1],
            [1],
            [1],
            [1],
        ],
        G:[
            [1,1,0],
            [0,1,1],
        ],
        H:[
            [1,0],
            [1,1],
            [0,1],
        ],
        S:[
            [1,1,1],
            [0,0,1],
        ],
        T:[
            [1,0,0],
            [1,1,1],
        ],
        M:[
            [1,1],
            [0,1],
            [0,1],
        ],
        L:[
            [1,0],
            [1,0],
            [1,1],
        ],
    };
    const ShapeService = {

        pushMatter: shape => shape.map(L=>[0, ...L]),

        antiMatter: shape => shape.map(L=>[L.toReversed()][0]),
        antiEnergy: shape => shape.map(L=>L).toReversed(),

        makeMirror: shape => shape.reduce(
            (Out,level,e) => level.map(
                (quant,c) => [...Out[c], quant]
            ), [[],[],[],[],[],[]] ),

        join: (field, shape) => {
            const makeMirror = shape => shape.reduce(
                (Out,level,e) => level.map(
                    (quant,c) => [...Out[c], quant]
                ), [[],[],[],[],[],[]] );

            const makeJoined = (field, shape, h) => field.reduce(
                    (Ox,Le,e) => [...Ox, Le.map(
                        (x,c) => {
                            const mix = true
                                && e >= h
                                && e <  h+ shape.length
                                && c <  shape[0].length
                                ;
                            const y = mix && shape[e-h][c] ||0;
                            return y||x;
                        })],[]);

            const w  = x => x >= 1;
            const Mf = makeMirror(field);
            const Ms = makeMirror(shape);
            const Hm = (h,a,c) =>(
                e => e>h ? e:h
            )(
                Ms[c] && Ms[c].find(w)?
                 1
                +1* Mf[c].findLastIndex(w)
                -1* Ms[c].findIndex(w)
                :0
            );
            const h = Mf.reduce(Hm,0);
            return makeJoined(field, shape, h);
        },

//        Ex: shape =>
//            shape.reduce(
//                (Ex,layer,e) =>
//                    layer.reduce(
//                        (Ee,q,c) => {
//                            const p = shape[1+1*e][c];
//                            const pressure = (q,p) => 1*q+p*1 >= 1;
//                            return pressure(q,p)
//                                ? Ee
//                                : Ee++
//                                ; }
//                        ,Ex)
//                ,0),
//        excited:  shape =>
//            shape.map(e =>
//                e.map(q => q?'x':'o')
//                    .join('')
//                        );
//        ,
        shakeOnce: 1,
    };
//    console.log('ShapeService', ShapeService.Ex(shape['G']));

    // const M = f => [ (x,e) => f({x,e}) ];
    // shape => shape.map(M(func)[0]).map(M(wave)[0])

    const shapeProfile = shape => {
        const makePool = shape =>
            shape.map(e =>
                e.map(q => q?'x':'o')
                    .join('')
                        );
        makePool(shape)
            .forEach((slice,e) =>
                console.log(`${e}:${slice}`)
                    );
    };

/*
    const fieldWithShape = (field,shape) => {
        const Gb = (q,p) => (C=> 1*q+p*1 >=C)(1)
        const Gi = (q,p) => (C=> 1*q+p*1  *C)(1)
        const fV = shape =>
            shape.map( (e,i) =>
                e.map( (c,j) => ({
                    x:i,
                    y:j,
                    m:c,
                })));
        const fW = shape =>
            shape.map( (e,i) =>
                e.map( (c,j) =>
                   Gb( fV[i,j])
                     ));
        const fV = field =>
            shape.map( (e,i) =>
                e.map( (c,j) => ({
                    x:i,
                    y:j,
                    m:c,
                })));
    };
    const fieldFilledByShape = (field,shape) => {
        const dFil = ( shape =>
            shape.map( (e,p) =>
                e.map( (b,c) => field.reduce(
                     (m,d,q) => 1*d+b*1 >=1? 1*q+p*1 :0,0
                 ))))( shape );
    };
*/


//    console.group('ShapeService.makeMirror');
//    console.log(
//        ShapeService.makeMirror(shape['G'])
//    );
//    shapeProfile(shape['G']);
//    shapeProfile(
//        ShapeService.makeMirror(shape['T'])
//    );
//    shapeProfile(shape['T']);
//    console.groupEnd('');

//    shapeProfile(field);
//    console.group('ShapeService.join');
//    const field2 = ShapeService.join(
//        field,
//        shape['G']
//        );
//    shapeProfile(shape['G']);
//    shapeProfile(field2);
//    const field3 = ShapeService.join(
//        field2,
//        shape['H']
//        );
//    shapeProfile(shape['H']);
//    shapeProfile(field3);
//
//    console.groupEnd('');
//    shapeProfile(shape['T']);
//    shapeProfile(ShapeService.makeMirror(shape['T']));
//    shapeProfile(shape['G']);
//    console.log()
</script>
<script display-source>

    console.group('WorldShapeMaster');
    const WM = new WorldShapeMaster();

    const Fm1 = WM.born({form:'field'});
    const Sm1 = WM.born({form:'F'});
    const Sm2 = WM.born();
    const Sm3 = WM.born();
    console.log('Sm1:',Sm1);
    shapeProfile(Sm1.shape);
    console.log('Sm2:',Sm2);
    shapeProfile(Sm2.shape);
    console.log('Sm3:',Sm3);
    shapeProfile(Sm3.shape);

    Sm2.push();
    Sm3.push();
    Sm3.push();
    Fm1.take(Sm1);
    Fm1.take(Sm2);
    Fm1.take(Sm3);

    console.log('Fm1:',Fm1);
    shapeProfile(Fm1.shape);

    console.log(
        'tests',
        //WM.Fsf.findMergeH(Fm1.shape,Sm1.shape)
        //WM.Fsp.dataEnergy(Sm1.shape,false)
        //WM.Fsp.dataMirror(Sm1.shape)
    );

    console.groupEnd();


//    console.group('WorldShape');
//    const nSG = new WorldShape({form:'G'});
//    console.log('nsG:',nSG);
//    shapeProfile(nSG.shape);
//    console.groupEnd();

</script>
</body>