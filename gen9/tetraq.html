<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>tetra q</title>
    <style display-source>
        [display-source] {
            display:     block;
            padding:     0 1em 2em;
            font-family: monospace;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
<script display-source>
    // ADFGHLMST
    // LH
    // XOQ - PUBEY
    // ecxydqpb
    const WorldShapeConfig = {
        field: [
            [0,0,0,0,0,0],
            [0,0,0,0,0,0],
            [0,0,0,0,0,0],
            [0,0,0,0,0,0],
            [0,0,0,0,0,0],
            [0,0,0,0,0,0],
            [0,0,0,0,0,0],
            [0,0,0,0,0,0],
            [0,0,0,0,0,0],
        ],
        shape: {
              A:[
                [1,1],
                [1,1],
            ],D:[
                [1,1,1,1],
            ],F:[
                [1],
                [1],
                [1],
                [1],
            ],
            G:[
                [1,1,0],
                [0,1,1],
            ],
            H:[
                [1,0],
                [1,1],
                [0,1],
            ],
            S:[
                [1,1,1],
                [0,0,1],
            ],
            T:[
                [1,0,0],
                [1,1,1],
            ],
            M:[
                [1,1],
                [0,1],
                [0,1],
            ],
            L:[
                [1,0],
                [1,0],
                [1,1],
            ],
        },
        Qb: q=> q?1:0,
        Qx: d=> 1,
        Qo: d=> 0,
        Qw: q=> 1 <=q,
        Wq: q=> 1 * q,
    };
    const WordShape = function (DNA={}) {
        const {field, shape} = WorldShapeConfig;
        const { Qx, Qo, Qw } = WorldShapeConfig;
        const services = {
            pushMatter: shape => shape.map(Le=>[Qo(), ...Le]),
            antiMatter: shape => shape.map(Le=>[Le.toReversed()][0]),
            antiEnergy: shape => shape.map(Le=>Le).toReversed(),
            fromBinary: shape => shape.map(Le=>Le.map(q=>[Qb(q)][0])),
            checkShape: shape => Array.isArray(shape) && shape.reduce(
                    (R,layer) => Array.isArray(layer) && R
                    ,true),
            dataMirror: shape => shape.reduce(
                (ap,Le,e) => Le.map(
                    (q,c) => [...ap, q]
                ),  shape[0].map(G=>[])
                ),
            joinShapes: (field, shape, h) => field.reduce(
                (ap,Le,e) => [ ...ap,Le.map(
                    (x,c) => {
                        const U = true
                            && e >= h
                            && e <  h+ shape.length
                            && c <  shape[0].length
                            ;
                        const y = U && shape[e-h][c] || Qo();
                        return y||x;
                    })],
                    []),
            randomShape: shapes => shapes[(
                K => K[Math.floor(Math.random()*K.length)]
                )( Object.keys(shapes) )],
        };// end of shapeService

        const Ribosome = DNA => ({
            shape: (fn => {
                if (DNA.shape && services.checkShape(DNA.shape)) return DNA.shape;
                if (Object.keys(shape).includes(DNA.form)) return shape[DNA.form];
                if (DNA.form === 'field') return field;
                const randomShape = shape[
                    Object.keys(shape)[
                        Math.floor(
                            Math.random()*Object.keys(shape).length
                        )
                    ]
                ];
                return randomShape;
            })(),
            DNA,
        });
        const transcription = Ribosome(DNA);
        const RNA = Object.assign(this,transcription);
    };
</script>
<script display-source>
    const field = [
        [0,0,0,0,0,0],
        [0,0,0,0,0,0],
        [0,0,0,0,0,0],
        [0,0,0,0,0,0],
        [0,0,0,0,0,0],
        [0,0,0,0,0,0],
        [0,0,0,0,0,0],
        [0,0,0,0,0,0],
        [0,0,0,0,0,0],
    ];
    const shape = {
          A:[
            [1,1],
            [1,1],
        ],D:[
            [1,1,1,1],
        ],F:[
            [1],
            [1],
            [1],
            [1],
        ],
        G:[
            [1,1,0],
            [0,1,1],
        ],
        H:[
            [1,0],
            [1,1],
            [0,1],
        ],
        S:[
            [1,1,1],
            [0,0,1],
        ],
        T:[
            [1,0,0],
            [1,1,1],
        ],
        M:[
            [1,1],
            [0,1],
            [0,1],
        ],
        L:[
            [1,0],
            [1,0],
            [1,1],
        ],
    };
    const ShapeService = {

        pushMatter: shape => shape.map(L=>[0, ...L]),

        antiMatter: shape => shape.map(L=>[L.toReversed()][0]),
        antiEnergy: shape => shape.map(L=>L).toReversed(),

        makeMirror: shape => shape.reduce(
            (Out,level,e) => level.map(
                (quant,c) => [...Out[c], quant]
            ), [[],[],[],[],[],[]] ),

        join: (field, shape) => {
            const makeMirror = shape => shape.reduce(
                (Out,level,e) => level.map(
                    (quant,c) => [...Out[c], quant]
                ), [[],[],[],[],[],[]] );

            const makeJoined = (field, shape, h) => field.reduce(
                    (Ox,Le,e) => [...Ox, Le.map(
                        (x,c) => {
                            const mix = true
                                && e >= h
                                && e <  h+ shape.length
                                && c <  shape[0].length
                                ;
                            const y = mix && shape[e-h][c] ||0;
                            return y||x;
                        })],[]);

            const w  = x => x >= 1;
            const Mf = makeMirror(field);
            const Ms = makeMirror(shape);
            const Hm = (h,a,c) =>(
                e => e>h ? e:h
            )(
                Ms[c] && Ms[c].find(w)?
                 1
                +1* Mf[c].findLastIndex(w)
                -1* Ms[c].findIndex(w)
                :0
            );
            const h = Mf.reduce(Hm,0);
            return makeJoined(field, shape, h);
        },

//        Ex: shape =>
//            shape.reduce(
//                (Ex,layer,e) =>
//                    layer.reduce(
//                        (Ee,q,c) => {
//                            const p = shape[1+1*e][c];
//                            const pressure = (q,p) => 1*q+p*1 >= 1;
//                            return pressure(q,p)
//                                ? Ee
//                                : Ee++
//                                ; }
//                        ,Ex)
//                ,0),
//        excited:  shape =>
//            shape.map(e =>
//                e.map(q => q?'x':'o')
//                    .join('')
//                        );
//        ,
        shakeOnce: 1,
    };
//    console.log('ShapeService', ShapeService.Ex(shape['G']));

    // const M = f => [ (x,e) => f({x,e}) ];
    // shape => shape.map(M(func)[0]).map(M(wave)[0])

    const shapeProfile = shape => {
        const makePool = shape =>
            shape.map(e =>
                e.map(q => q?'x':'o')
                    .join('')
                        );
        makePool(shape)
            .forEach((slice,e) =>
                console.log(`${e}:${slice}`)
                    );
    };

/*
    const fieldWithShape = (field,shape) => {
        const Gb = (q,p) => (C=> 1*q+p*1 >=C)(1)
        const Gi = (q,p) => (C=> 1*q+p*1  *C)(1)
        const fV = shape =>
            shape.map( (e,i) =>
                e.map( (c,j) => ({
                    x:i,
                    y:j,
                    m:c,
                })));
        const fW = shape =>
            shape.map( (e,i) =>
                e.map( (c,j) =>
                   Gb( fV[i,j])
                     ));
        const fV = field =>
            shape.map( (e,i) =>
                e.map( (c,j) => ({
                    x:i,
                    y:j,
                    m:c,
                })));
    };
    const fieldFilledByShape = (field,shape) => {
        const dFil = ( shape =>
            shape.map( (e,p) =>
                e.map( (b,c) => field.reduce(
                     (m,d,q) => 1*d+b*1 >=1? 1*q+p*1 :0,0
                 ))))( shape );
    };
*/


//    console.group('ShapeService.makeMirror');
//    console.log(
//        ShapeService.makeMirror(shape['G'])
//    );
//    shapeProfile(shape['G']);
//    shapeProfile(
//        ShapeService.makeMirror(shape['T'])
//    );
//    shapeProfile(shape['T']);
//    console.groupEnd('');

    shapeProfile(field);
    console.group('ShapeService.join');
    const field2 = ShapeService.join(
        field,
        shape['G']
        );
    shapeProfile(shape['G']);
    shapeProfile(field2);
    const field3 = ShapeService.join(
        field2,
        shape['H']
        );
    shapeProfile(shape['H']);
    shapeProfile(field3);

    console.groupEnd('');
//    shapeProfile(shape['T']);
//    shapeProfile(ShapeService.makeMirror(shape['T']));
//    shapeProfile(shape['G']);
//    console.log()
</script>
</body>